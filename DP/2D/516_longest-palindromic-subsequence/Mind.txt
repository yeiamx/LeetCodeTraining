解题思路：
可以求倒序字符串与本串之间的最长公共子序列长度。也可以直接DP做。我们直接DP

状态：S[l..r]中的最长回文子序列长度
根据最长回文子序列可能出现的位置分类，和1143_最长公共子序列类似
if S[l] == S[r] fn(l, r) = f(l+1, r-1) + 2,
else {
    f(l, r) = Math.max(fn(l+1, r), fn(l, r-1))
}
其中l <= r;
因此可构造递归边界：l == r时 return 1 l+1 == r时 return s[l] == s[r] ? 2 : 0;
递归以及记忆化搜索跳过

长度为n，0 <= l <= n-1， 0 <= r <= n-1,  l<=r
即我们只要填nxn矩阵的右上半（包含对角线）部分
然后观察依赖，当前格子依赖左、左下、下。通过递归边界我们可以画出对角线和对角线右上方角线的值。然后观察图形，我们可知需要从下至上，从左至右即可填充dp

空间压缩：
和题1143类似：从下到上，从左到右填充一维数组，这样左、下都能确定（下即当前格子的值）。然后利用tmp记录leftDown即可。

