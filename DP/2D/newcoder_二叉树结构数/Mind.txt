解题思路：
关于二叉树的dp经常围绕头节点进行讨论，观察指定头节点后能否围绕其子节点构造出子问题并还原出当前头节点下的解

fn(i, j) = 满足节点个数为i且树的高度不超过j的方案
当i = 0时，j=0时 fn = 1；当i = 0， j > 0 or i > 0 j = 0 时，fn = 0
i > 0时显然无论是什么树，都要有一个头节点
那排除掉头节点，还剩i-1个节点。即左右子树可以使用i-1个节点，同时高度要<= j - 1(头节点占了一个高度)
那我们列出左右子树所有不同的节点分配方案： 0 i-1， 1 i-2, ...leftNum rightNUm
对于某种特定的节点分配方案，易得节点分配方案 = f(leftNum, j-1) * f(rightNum, j-1)
那么fn(i,j)无非就是这些所有可能性下的节点分配方案数之和 fn(i, j) = Sum(f(k, j-1) * f(i-k-1, j-1)) (0<=k<=i-1)

依赖：i,j 依赖第j-1列.行的话：看k、i-k-1的范围：在0-i-1
所以其实格子依赖左上往上直直的一溜
o
o
o
o
o
 X
直觉上行从上往下 列从左往右 ，可以填完所有格子

空间压缩：如果行从上往下 列从左往右 ，似乎并不能用1D的dp数组滚出来，因为自我更新的过程中本身最多也就保存上一行的数据。
于是我们考虑换种更新顺序，先更新第y列，第y+1列从下到上更新就没有问题,每次自我更新都能从本身dp数组中找到左上一溜的数据



