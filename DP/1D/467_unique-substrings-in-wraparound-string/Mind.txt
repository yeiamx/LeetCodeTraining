解题思路：

状态：以S[i]结尾的最长”匹配子串“长度。即从第i位向左探，找到一个最长的在环绕串中的子串。
例子：zabpxyzab
i=2时，S[2] = 'b',向左探b、ba、baz都是环绕串的子串，所以dp[2]=3
i=3时，S[3] = 'p',向左探只有本身p是环绕串的子串,所以dp[3] = 1

状态->题解：向不论递推过程，假设我们可以顺序推出dp[0]...dp[len-1]
我们可以维护出一个长度为26的表，用于表示字符串S中，以不同字符（'a'-'z'）结尾的最长”匹配子串“长度。
S中所有的”匹配子串“个数即为表中总和。
因为S中若存在一个以字符ch结尾的最长”匹配子串“，那么S中所有的以字符ch结尾的”匹配子串“都是它的后缀。
如zabpxyzab，以b结尾的最长为xyzab，那么以b结尾的只能是b ab zab yzab xyzab. 不可能有别的以b结尾的了，若有，则xyzab就不是最长的。

转移：
if S[i] is next(S[i-1]) dp[i] = dp[i - 1]
ELSE dp[i] = 1
