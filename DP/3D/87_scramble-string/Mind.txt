解题思路：
先给出递归定义：f(s, l1, r1, t, l2, r2):t[l2..r2]是否s[l1..r1]的扰乱串

我们先顺着题意探究一下怎么得到串s的扰乱串集合
把题目稍微抽象一下
设函数fn(s, l, r)输出s[l..r]的扰乱串集合,
第一步我们需要将s[l..r]分成两部分，然后分别将两部分对换，得到第一批左右节点
s[l], s[l+1..r]; s[l,l+1], s[l+2..r];...s[l..r-1], s[r];
s[l+1..r], s[l]; s[l+2..r], s[l,l+1];...s[r], s[l..r-1];
称左半部分为s_left右为s_right, 各自的区间开头结尾为part_start, part_end
res = {}
for every part
    res.add(fn(s_left, part_start, part_end) * fn(s_left, part_start, part_end))  （乘代表集合乘）
即遍历所有的“两两部分”，得出左部分所有的扰乱串，右部分的所有扰乱串，然后两两组合出一系列新的扰乱串，加入结果集合中
那怎么判断t是不是s的扰乱串呢，因为t也是由上述过程得出的，所以其对应的部分一定是s中对应部分所生成的扰乱串
以s[l], s[l+1..r]举例，t[l]在fn(s[l])的集合中，且t[l+1..r]在fn(s[l+1..r])的集合中，那么t就是s的扰乱串。
以s[l+1..r], s[l]举例，t[l..r-1]在fn(s[l+1..r])的集合中，且t[r]在fn(s[l])的集合中，那么t就是s的扰乱串。
即遍历所有的左右节点，有一个满足了，t就是s的扰乱串。
这里其实已经出现了子问题,即fn(s, l, r)变成了fn(s的子串)

递归：
遍历过程参考如上,遍历到一种情况为true就返回true
边界l1==r1 return s[l1] == t[l2]
从递归上看有四个可变参数，但s和t的长度始终是一致的，因此可看作三个参数l1, l2, len，用它们就能构造出所有的“第一批左右节点”
DP状态： dp[l1][l2][len]：boolean 不解释了




