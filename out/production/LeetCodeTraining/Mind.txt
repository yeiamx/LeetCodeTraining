解题思路：
状态：dp[i][z][o]
从strs[i...]中选取子集，0、1不超过z、o的选法里，最大的子集长度

转移：
所有的选法中，要么选strs[i], 要么不选
不选：p1 =  dp[i+1][z][o]
选: strs[i] contains zeros 0, ones 1, and if zeros <= z, o <= ones
p2 = 1 + dp[i+1][z-zeros][o-ones]

递推：从三维的视角看，第i层只依赖i+1层。那么我们从最高层（strs.length - 1），一层层往下推即可。

边界：第len层：即空集中选子集，子集长度无论如何都是0.

空间压缩：不选，那数组本身也不用动
选，dp[z][o] 依赖于dp[z-zeros][o-ones], 即坐标z,o左下部分的数据
O
|
|---------(z,o)
|           |
|           |
|           |
0—— —— —— —— —— —— ——Z
我们需要确保在自我更新时,坐标(z,o)左下部分的数据都是没被更新过的
通过从右上角出发列从右向左，行从上到下的顺序，可以保证。
最后一层(最下)我们只需要更新右上角，即可得出答案dp[0][z][o]
