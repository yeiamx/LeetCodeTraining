解题思路：
状态dp[i][r][s]:从工作[i...]列表中进行选择，满足总人数<=r, 总利润>=s的方案总数

边界：
if r<=0
    dp = s<=0 ? 1:0
else if i==len (r > 0)
    dp = s<=0 ? 1:0

转移：所有方案中，不要work[i]:p1 = dp[i+1][r][s]
要work[i]: if (g[i] <= r) p2 = dp[i+1][r - g[i]][s-p[i]]
dp = p1 + p2

需要注意的是，s-p[i]如果为负数，我们不会在边界做判断处理。因为利润小于0时，我们也要继续分配工作，方案数也会累加。
因为此时利润已经达标了，所有的方案都可行。但反过来说，只要利润达标，负数和0其实没有区别。
因此我们可以控制s-p[i] >= 0, 从而不让递归的可变参数到0以下，从而方便计算dp数组
SO if (g[i] <= r) p2 = dp[i+1][r - g[i]][max(s-p[i], 0)]

递推：详见474

边界：顶层，i=len，没有工作的时候，仅当s=0时，dp = 1. SO
dp[r][0] = 1;
