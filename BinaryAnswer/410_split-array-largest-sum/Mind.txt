解题思路：
分析：
先从题意开始：有个一个nums，给定一个限制k，让你把nums分成k个部分。
我们分法抽象成一个p集合
p[i]对应一个值max_p_sum[i]：遍历p[i]这种分法下的所有部分, 每个部分的累加和中的最大值，定义为max_p_sum[i];
例子：nums : 1 3 2 4 5 k=3
那假设p[i]对应分法，1; 3 2 4; 5;那三部分中的累加和分别为1、9、5，max_p_sum[i]取最大值9。
然后我们遍历max_p_sum，Min（max_p_sum）即为题解 ans。
如果简化一下，就是f(nums, k) = ans

然后我们开始灵感,已知二分答案法，我们就找题解的范围以及构建一个以题解为参数，条件为输出的单调性函数。
因为ans本质是一段子数组和，ans的范围可以大致确定为[0, sum(nums]]

然后构建g(nums, A): 将数组nums进行分段，每段的子数组和都<= A的最小段数。

关键：
IF g(nums, A) <= k:等于nums可以构造出一种分法，分k段，而且每段和都<=A;
因为即便g(nums, A) < k, 也一定能构造出k段让每段和都<=A, 毕竟段数越小条件越严苛不是吗
我们再回头看p（分法）集合。我们找到了一种分法p[i]，对应一个max_p_sum[i], 其<=A.
此时ans是所有max_p_sum[i]的最小值,SO ans <= A

即IF g(nums, A) <= k, A >= ans
而g(nums, A)有单调性，A越大，g(nums, A)越小。
因此大于A的值我们就可以排除了。

使用二分查找即可

