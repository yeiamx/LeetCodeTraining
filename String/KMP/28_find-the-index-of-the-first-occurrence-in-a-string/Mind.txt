解题思路：
KMP：https://www.bilibili.com/video/BV19Q4y1c7ko/?spm_id_from=333.337.search-card.all.click&vd_source=282a3f4df10e266c261a9a88da6ee172
文本串t
模式串p
暴力算法：模式串第0位不断和文本串的第i位对齐，然后compare p[0] with t[i], p[1] with t[i+1]....
if can finish，res = i;
else {i++; compare p[0] with t[i], p[1] with t[i+1]....}
为什么这样慢，因为每次对齐再比较地这个过程是独立的，我们其实可以利用之前比较中获得的信息进行加速。

1.KMP的执行
    1.1 概念（前后缀、最大相等前后缀长度、next数组）
    2.1 利用next数组跳跃式地滑动模式串，跳跃式地移动模式串中的指针
2.假设next数组的正确性下，为什么KMP可以这么执行
    2.1 既然我们滑动了模式串，说明存在文本串中被滑动所忽略的字符，文本串中以这些字符为开头去匹配p一定是失败的。为什么。
    2.2 执行时，在模式串中我们也不是从p[0]去和t[i]匹配，而是从p[next[j]]和t[i]匹配。为什么。
3.怎么计算next数组
    首先我们计算next数组时肯定是递进式的，即由next[0]-next[i-1]的值得到next[i]. 其中易得next[0] = -1; next[1] = 0;
    假设对于模式串p我们已知next[0]-next[i-1], 要计算next[i]
        当p[next[i-1]]==p[i-1]时，易得p[0-i-1]中存在一个长度为next[i-1] + 1 的相等前后缀。且可反证该前后缀是p[0-i-1]中的最长相等前后缀。
            此时易得next[i] = next[i - 1] + 1
        当p[next[i-1]]!=p[i-1]时
            我们在求next[i], 即p[0-i-1]中的最长相等前后缀。如存在前后缀，则i-1肯定是后缀的尾巴
            我们的目标其实是找到一个k，让p[0...k-1,k] == p[i-1-k..., i-2, i-1].这个k还要越大越好。
            利用next数组的性质，我们可以轻松定位到k的可能值。原理是如果p[0...k-1]需要匹配p[i-1-k..., i-2]，只有特定的几个K是成立的，而这几个K可以通过next数组获得。（怎么定位？怎么利用反证法证明？）
            那我们从大到小遍历可能的k，如果p[k] == p[i-1]那么这个k即为p[0-i-1]中的最长相等前后缀的长度，也就是next[i]的值。
4.复杂度分析
    TODO.
