解题思路：
完整的题意：
插入一个字符，代价a
删除一个字符，代价b
替换一个字符，代价c

状态:dp[i][j] = word1[0..i-1]转换为word2[0..j-1]所需要的最小操作数
转移：
还是先分类，对最优操作的可能情况作详尽地切分（若干个不相交但完备（能合回来）地子集）
由于操作顺序不影响结果，我们可以按照存不存在对某个字符的某个操作去对操作序列进行分类。
首先按照最优操作方案中word1[i-1]有无被删除分类
1.若删除了word1[i-1], dp[i][j] = dp[i-1][j] + b;
2.若word1[i-1]没被删除
    2.1若word2[j-1]在操作中是由插入操作得到的 dp[i][j] = dp[i][j-1] + a
        这里补充一下一个思维误区，那为什么不是dp[i][j-k] + k * a.其实这只是dp[i][j-1]的一个子集，没有必要讨论。
    2.2若word2[j-1]在操作中不是由插入操作得到的，由于它是最后一个字符，只能由word1[i-1]变换而来（不是的话，word1[i-1]也没删除，那它去哪了.由于相对次序，它不可能在前面）
        如果word1[i-1] == word2[j-1]，那么就不用动dp[i][j] = dp[i-1][j-1]
        else dp[i][j] = dp[i-1][j-1] + c
