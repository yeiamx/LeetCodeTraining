解题思路：
2D-DP的入门题，我们写详细点
从分析题意，利用递归开始，然后转为记忆化搜索，然后转为递推式，然后进行空间压缩

状态：fn(i, j) = S1[0..i] 和 S2[0..j]的最大公共子序列长度
按照子序列maxSeq在S1和S2出现的范围，可以粗略地分为四种情况。
1：maxSeq的结尾都落在S1和S2的结尾
2：maxSeq的结尾都落在S1和S2内
3：落在S1的结尾，落在S2内
4：落在S2的结尾，落在S1内
换句话说，要求S1[0..i] 和 S2[0..j]的最大公共子序列
我们只要找到满足这四个条件（任意一个）的所有maxSeq，然后取长度最大的那个maxSeq即可。
那么要求S1[0..i] 和 S2[0..j]的最大公共子序列【长度】，只需要取这四个范围条件下的最大公共子序列长度的max值。

fn(i, j) = MAX(fn(i-1, j-1) + 1, fn(i, j-1), fn(i-1, j), fn(i-1, j-1))

然后其实我们可以做优化：先不看第一种情况，因为我们要求的是最长子序列。第三第四种情况一定优于第二种情况。
因为[0,i-1][0,j-1]这个范围是3、4的子集。你就算maxSeq的结尾落在[0,i-1][0,j-1]上，3、4也肯定能得到一样的解.
因此我们就不用考虑情况2
然后看情况1，如果S1[i] == S2[j], 我们就不用考虑情况2、3.最后一个字符已经匹配上了，那自然是尽快获取收益，然后让前面的串尽可能地长，从而获取尽可能长的最大子序列
比如S1[i] == S2[j] == ‘a'时，我就不用S2的S2[j]去匹配S1[i], 我用S2[k] == 'a'（k<j）去匹配S1[i],也就是情况3
那结果就是fn(i-1, k-1) + 1肯定<=fn(i-1, j-1) + 1。情况4同理。

fn(char[] s1, char[] s2, int i, int j) {
    if (i < 0 || j < 0) return 0;
    if (s1[i] == s2[j]) return fn(s1, s2, i-1, j-1) + 1
    else {
        return Math.max(fn(s1, s2, i-1, j), fn(s1, s2, i, j-1));
    }
}
然后下一步我们改成记忆化搜索，即挂个dp，dp[i][j] = fn(i,j).
但是这里有个问题，i,j可能小于0，我们总不可能dp[-1][..] = 0;因此用到一个小技巧，将下标转为长度，在递归过程中就避免掉可变参数小于0的情况。
//s1[len1] s1[len2]
fn(char[] s1, char[] s2, int len1, int len2) {
    if (len1 == 0 || len2 == 0) return 0;
    if (s1[len1-1] == s2[len2-1]) return fn(s1, s2, len1-1, len2-1) + 1
    else {
        return Math.max(fn(s1, s2, len1-1, len2), fn(s1, s2, len1, len2-1));
    }
}
挂dp的就不写了，给dp初始化个-1，代表有没有存储过，然后边查边存即可

递推式：
关注len1, len2两个变量。依赖于(len1-1,len2-1), (len1-1,len2), (len1,len2-1), 即左上、左、上
易得第一行，第一列为0，设范围为m, n 我们只要从1,1 开始 从左向右 从上向下填充 即可得到答案 dp[m, n]
这样空间O(m * n)
但其实我们用O(m)即可完成填充，即用一个长度为n的横向列表list自上而下地更新。最后list(n)即为答案
当更新下标i行时，由于当前list记录的是i-1行地信息，然后我们再从左向右更新到list[j]也就是dp[i][j]
此时所依赖的dp[i-1][j] = list[j-1], dp[i][j-1] = list[j].
而dp[i-1][j-1]需要注意，它是左上角地值，也就是list[j-1]在更新前的值，所以我们需要用一个tmp记录list[j]左边list[j-1]在更新前的值，即dp[i-1][j-1]

然后我们还可以让list的长度尽可能的小，即让n为s1 s2中更短的那个字符串的长度。

这样就是最优解了 code见solution












