解题思路：
首先明确 丑数一定是由某个丑数乘2、3、5得来的。
因此可以想出暴力法，已知的丑数列表u_nums[0,...i-2]， 求第i个丑数（下标在丑数列表中为i-1）。我们可以对丑数列表里的所有数*2,*3,*5，然后选一个大于u_nums[i-2]的最小的ugly_num

暴力法我们可以稍微优化一下：
    将每个数*2,*3,*5的过程分为所有数先*2、然后*3、然后*5，得到三个集合【*2】【*3】【*5】。得到的总集合还是一样的，顺序变一变而已
    在列表u_nums[0,...i-2]*2的过程中，我们会得到一个递增丑数列表，当列表中第一次出现u_nums[i2] * 2 > u_nums[i-2]时，我们记录一下i2, 然后i2 - i-2的数就不用乘了，虽然乘出来的也是符合条件的丑数，但是已经有比它小的答案了。
    3、5同理，可以得到i3、i5.
    计算完之后我们从【丑数列表里的所有数*2,*3,*5】这个集合中得到了三个备选答案。那么只要取出三个备选答案的最小值，即为暴力法也就是我们想要的解。

可以通过指针法动态维护i2， i3， i5
在已知的丑数列表u_nums[0,...i-2]中维护3个指针p2, p3, p5.
指针的定义和上述相同，p2即为列表中第一次出现u_nums[i2] * 2 > u_nums[i-2]时的i2.
参考上述说明，易得u_nums[i-1] = min(nums[p2] * 2, nums[p3] * 3, nums[p5] * 5)

此时列表发生了改变，我们如果能够维护出新的p2, p3, p5，那么整个列表就能递推式地计算下去。
维护方法：若nums[p2] * 2为最小值，则p2 = p2 + 1 p3 p5不动， 3、5同理
证明：当我们把u_nums[i-1]=nums[p2] * 2时，因为丑数序列是递增的，下一个u_nums[i-1]=nums[p2] * 2的【*2】集合中的解一定是nums[p2+1] * 2
而对于p3、p5,在新列表里它们也一定是【*3】【*5】里第一个大于最后一个丑数的：首先u_nums[p3],u_nums[p5]一定大于，因为最后一个丑数是我们取最小值得到的
其次它们一定还是第一个，因为u_nums[p3-1] < u_nums[i - 1] < u_nums[i]
