解题思路：
讨论以s[R]结尾的能覆盖t的最短子串,遍历R得到题解

找到R=r,s[0..r]能够覆盖t. 此时R不可能=0..r-1
s[0..r-1]无法覆盖,判断加入s[r]后覆盖:
可以维护s[0..r-1]的字符情况,维护还需要覆盖多少个字符left_count.
若加入的字符对我们有帮助(通过比较s和t的字符情况判断, 即便加入的字符在t中,但如果s已经覆盖了足量的字符,那加入的字符也是没用的. 比如s='AAAAA' t='AAB', 当r=2时可不能去将需要覆盖的字符数--)
    left_count--;
    if left_count == 0 break;

左缩 find min window [l..r]

已知[l..r] 为 r结尾的min window, 讨论r+1
其L不可能小于l，因为[l..r+1]一定覆盖t
So，直接让L从l位置开始，看看能不能删掉当前位置依旧覆盖t，如果在l‘位置发现不能，则r+1对应的l为l'-1;



