解题思路：
在前缀信息篇，我们做过寻找累加和等于k的最长子数组。
解法为关注以nums[i]结尾的子数组中符合条件的最优解。遍历i得到题解。
以nums[i]结尾时，我们只需要找到最短的前缀nums[0..j](j < i)，使得其前缀和等于sum[0..i] - k, 即找到了 累加和等于k的最长子数组nums[j+1...i]。然后找第一个等于某个数的前缀和对应下标我们用的是hashmap

这题大体思路类似，对于nums[i]
找累加和>=k的最短子数组，即找到【最长的前缀nums[0..j](j < i)，使得其前缀和sum[0..j] <= sum[0..i] - k】.此时存在最短的nums[j+1..i],sum[0..i] - sum[0..j] = sum[j+1..i] >= k

 可以利用单调队列去找到这个k。
 首先我们不要去想单调队列的性质，就单纯把它想象成一个队列，我们往里按下标顺序放前缀和（对应的下标）。尝试方法也就是很简单的从下标小的前缀和开始尝试，看看哪些前缀和能够满足上述要求，然后给出一个最大的
 而在我们去用队列里的某些前缀和不满足要求，以及将新的前缀和加入队列中时，会进行一系列操作，剔除队列里所有与后续最优解无关的前缀和。这些操作会赋予队列中的前缀和从小到大的性质。
 所以我们应该关注的是，进行了哪些操作？操作的合理性？
 先假设队列里的前缀和下标从小到大，值也从小到大。那么我们的目标就是从head开始找满足【】的前缀和。
    可能队列中的前缀和如下 满足  满足  不满足
                       0-3  0-5   0-7
    显然nums[i]对应的j就是5，同时0-3, 0-5这两个前缀和不再需要被讨论。因为即便4..I(I > i)  6..I(I > i) 是两个合法的子数组，它们的长度也一定不及子数组[6..i].
 然后运作到nums[i+1]为结尾，我们需要把前缀和sum[0...i]加入队尾。此时若队列中如果有 >= sum[0...i] 的前缀和，那么这些前缀和也一定不用再讨论。简单解释的话就是后续讨论中这些被遗弃的前缀和始终有一个更好的替代者：sum[0...i].
 显然，上述两个操作会使得队列中始终保持下标由小到大，前缀和从小到大的性质。那么求解过程便可一步步递推进行下去。同时一系列的剔除操作，帮助我们把时间复杂度控制在了O(n).



