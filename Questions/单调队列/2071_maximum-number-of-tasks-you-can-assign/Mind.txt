解题思路：
不难发现，在给定条件下：能否至少完成t个任务这件事是具备单调性的，即任务越多越难完成。可以尝试使用二分答案法，找到f(t) = true的t的右边界。
f(t)即为给定条件，能否完成t个任务。
此时有明显的贪心策略：采用力量最大的t个工人去完成力量需求最少的t个任务。

f:t个工人 完成 t个任务（sorted）， 能否完成？
大方向：从能力值小的工人开始，看当前工人是否能完成某个任务，不能就寄。能则为其分配一个任务。
且这个分配策略是最佳的，为后续工人提供了最好的选择环境。
那么这种递推策略显然就是最优解。

1.对于某个工人。前面可能已经分配了一些任务。在当前的所有任务中，如果他有能力完成一些任务。我们的策略就是让这个工人完成这些任务中的最小能力值任务。
这个策略肯定不会有问题，因为对于某个工人，在他能力值范围内的工作其实选择哪个都无所谓，不会影响到后续工人（毕竟后续的人更强）。

2.而如果当前任务中无法完成任意一个，那就吃药，找到一系列能完成的任务，然后完成能力值最高的那个任务。（如果还没有能完成的那就直接寄）
和上述一样，如果后续工人都吃药，他们也不会care你在你这一系列能完成的任务里选择那个。但是为了让药片消耗尽可能少，我们需要留下能力值小的任务，让后续工人即便不吃药也有可能完成这里面的一些任务。

上述即为药片消耗最少的情况下，让t个工人完成t个任务的策略。

使用双端队列可以实现上述策略：使用一个指针将”找过“的任务放入队列里，队列里的任务对于当前工人来说一定是能完成的（可能需要吃药）。且任务在队列中一定从小到大排序。

执行：
1.在任务列表里去找没有“找过”的任务，看看有没有能力值范围内的，加入队列。
如果此时队列头完成不了，说明1失败

2.吃药，找任务，完成队列尾。（此时寄的情况就是，找任务前队列空，然后吃药后你还找不到新任务）


